# 向后兼容性测试指南

## 测试目的

验证 MerchantConfig JSON 修复方案能够正确处理现有数据库中的各种 template_config 值，包括 NULL、空字符串和有效 JSON。

---

## 测试场景

### 场景 1：处理现有 NULL 值

**测试步骤：**
1. 在数据库中创建一个 template_config 为 NULL 的记录
2. 通过 API 读取该配置
3. 验证返回的 template_config 为 "{}"

**预期结果：**
- ✅ 读取成功，不抛出异常
- ✅ template_config 自动转换为 "{}"
- ✅ 用户无感知，透明处理

**SQL 测试：**
```sql
-- 创建测试数据
INSERT INTO t_merchant_config (merchant_id, merchant_name, template_config)
VALUES (1001, '测试商家-NULL', NULL);

-- 通过应用读取
-- GET /api/settings?merchantId=1001

-- 清理
DELETE FROM t_merchant_config WHERE merchant_id = 1001;
```

---

### 场景 2：处理现有空字符串

**测试步骤：**
1. 在数据库中创建一个 template_config 为空字符串的记录
2. 通过 API 读取该配置
3. 验证返回的 template_config 为 "{}"

**预期结果：**
- ✅ 读取成功
- ✅ 空字符串自动转换为 "{}"
- ✅ 后续更新不会出错

**SQL 测试：**
```sql
-- 创建测试数据
INSERT INTO t_merchant_config (merchant_id, merchant_name, template_config)
VALUES (1002, '测试商家-空字符串', '');

-- 通过应用读取
-- GET /api/settings?merchantId=1002

-- 清理
DELETE FROM t_merchant_config WHERE merchant_id = 1002;
```

---

### 场景 3：保留现有有效 JSON

**测试步骤：**
1. 在数据库中创建一个 template_config 为有效 JSON 的记录
2. 通过 API 读取该配置
3. 验证返回的 template_config 保持不变

**预期结果：**
- ✅ 读取成功
- ✅ 有效 JSON 值完全保留
- ✅ 不做任何修改

**SQL 测试：**
```sql
-- 创建测试数据
INSERT INTO t_merchant_config (merchant_id, merchant_name, template_config)
VALUES (1003, '测试商家-有效JSON', '{"key":"value","number":123}');

-- 通过应用读取
-- GET /api/settings?merchantId=1003

-- 验证值未改变
SELECT template_config FROM t_merchant_config WHERE merchant_id = 1003;

-- 清理
DELETE FROM t_merchant_config WHERE merchant_id = 1003;
```

---

### 场景 4：更新旧记录

**测试步骤：**
1. 读取一个现有的配置（可能有 NULL 或空值）
2. 修改其他字段（如 merchant_name）
3. 保存配置
4. 验证 template_config 被自动设置为 "{}"

**预期结果：**
- ✅ 更新成功
- ✅ template_config 自动清理为 "{}"
- ✅ 不再出现 JSON 错误

**API 测试：**
```bash
# 1. 读取配置
curl -X GET "http://106.55.102.48:8080/api/settings?merchantId=1" \
  -H "Authorization: Bearer <token>"

# 2. 更新配置
curl -X PUT "http://106.55.102.48:8080/api/settings" \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{
    "merchantId": 1,
    "merchantName": "更新后的商家名称",
    "meituanAppKey": "test-key"
  }'

# 3. 验证 template_config 为 "{}"
```

---

## 自动化测试

### 单元测试

```java
@Test
void testReadLegacyNullConfig() {
    // 模拟数据库返回 NULL
    MerchantConfig config = new MerchantConfig();
    config.setMerchantId(1L);
    config.setTemplateConfig(null);
    
    // 验证 getter 返回 "{}"
    assertEquals("{}", config.getTemplateConfig());
}

@Test
void testReadLegacyEmptyStringConfig() {
    MerchantConfig config = new MerchantConfig();
    config.setMerchantId(1L);
    config.setTemplateConfig("");
    
    // 验证自动转换为 "{}"
    assertEquals("{}", config.getTemplateConfig());
}

@Test
void testPreserveValidJson() {
    MerchantConfig config = new MerchantConfig();
    config.setMerchantId(1L);
    String validJson = "{\"key\":\"value\"}";
    config.setTemplateConfig(validJson);
    
    // 验证有效 JSON 被保留
    assertEquals(validJson, config.getTemplateConfig());
}
```

---

## 验证清单

在部署到生产环境前，请确认：

- [ ] 测试场景 1：NULL 值处理 ✅
- [ ] 测试场景 2：空字符串处理 ✅
- [ ] 测试场景 3：有效 JSON 保留 ✅
- [ ] 测试场景 4：更新旧记录 ✅
- [ ] 检查应用日志，确认清理操作被记录
- [ ] 验证系统设置页面可以正常保存
- [ ] 确认没有 JSON 相关错误

---

## 数据迁移（可选）

如果希望清理数据库中所有的 NULL 和空字符串值，可以执行以下 SQL：

```sql
-- 备份当前数据
CREATE TABLE t_merchant_config_backup AS 
SELECT * FROM t_merchant_config;

-- 更新所有 NULL 和空字符串为 "{}"
UPDATE t_merchant_config 
SET template_config = '{}' 
WHERE template_config IS NULL 
   OR template_config = ''
   OR TRIM(template_config) = '';

-- 验证更新结果
SELECT 
    COUNT(*) as total_records,
    SUM(CASE WHEN template_config = '{}' THEN 1 ELSE 0 END) as empty_json_count,
    SUM(CASE WHEN template_config IS NULL THEN 1 ELSE 0 END) as null_count
FROM t_merchant_config;
```

**注意：** 由于应用层已经自动处理，这个数据迁移是可选的，不是必需的。

---

## 监控建议

部署后，监控以下日志消息：

1. **JSON 清理日志：**
   ```
   检测到空的 template_config，已自动设置为空 JSON 对象，商家ID：{id}
   ```

2. **错误恢复日志：**
   ```
   检测到 JSON 相关错误，尝试使用默认 JSON 值重试，商家ID：{id}
   ```

3. **成功日志：**
   ```
   更新商家配置成功，商家ID：{id}，耗时：{ms}ms
   ```

如果看到大量清理日志，说明数据库中有很多旧数据，但这是正常的，系统会自动处理。

---

## 总结

向后兼容性已通过以下机制实现：

1. **实体层** - 构造函数初始化 + 自定义 setter/getter
2. **服务层** - 保存前自动清理
3. **错误恢复** - JSON 错误时自动重试

**无需手动数据迁移，系统会透明处理所有旧数据。**
